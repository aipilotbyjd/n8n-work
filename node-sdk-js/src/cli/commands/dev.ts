/**
 * Dev command - Start development server
 */

import { promises as fs } from 'fs';
import path from 'path';
import chalk from 'chalk';
import ora from 'ora';
import chokidar from 'chokidar';
import express from 'express';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import { WebSocketServer } from 'ws';
import { spawn, ChildProcess } from 'child_process';
import { EventEmitter } from 'events';

export interface DevServerConfig {\n  port: number;\n  host: string;\n  watchPaths: string[];\n  ignorePaths: string[];\n  enableHotReload: boolean;\n  enableDebugger: boolean;\n  enableLivePreview: boolean;\n  enableTesting: boolean;\n  nodeExecutionTimeout: number;\n  maxConcurrentTests: number;\n  logLevel: 'debug' | 'info' | 'warn' | 'error';\n  enableAnalytics: boolean;\n}\n\nexport interface NodeTestResult {\n  nodeId: string;\n  success: boolean;\n  output?: any;\n  error?: string;\n  executionTime: number;\n  memoryUsage: number;\n  timestamp: string;\n  testData: any;\n}\n\nexport interface DebugSession {\n  id: string;\n  nodeId: string;\n  breakpoints: number[];\n  variables: Record<string, any>;\n  callStack: string[];\n  isRunning: boolean;\n  createdAt: string;\n}\n\nexport class DevServer extends EventEmitter {\n  private config: DevServerConfig;\n  private app: express.Application;\n  private server: any;\n  private io: SocketIOServer;\n  private watcher?: chokidar.FSWatcher;\n  private nodeProcess?: ChildProcess;\n  private isRunning = false;\n  private connectedClients = new Set<string>();\n  private debugSessions = new Map<string, DebugSession>();\n  private testResults = new Map<string, NodeTestResult[]>();\n  private analytics = {\n    testsRun: 0,\n    hotReloads: 0,\n    debugSessions: 0,\n    uptime: Date.now()\n  };\n\n  constructor(config: Partial<DevServerConfig> = {}) {\n    super();\n    \n    this.config = {\n      port: 3000,\n      host: 'localhost',\n      watchPaths: ['./src', './nodes'],\n      ignorePaths: ['node_modules', '.git', 'dist', 'build'],\n      enableHotReload: true,\n      enableDebugger: true,\n      enableLivePreview: true,\n      enableTesting: true,\n      nodeExecutionTimeout: 30000,\n      maxConcurrentTests: 5,\n      logLevel: 'info',\n      enableAnalytics: true,\n      ...config\n    };\n\n    this.setupExpressApp();\n    this.setupSocketIO();\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error('Dev server is already running');\n    }\n\n    const spinner = ora('Starting N8N-Work development server...').start();\n\n    try {\n      // Start the HTTP server\n      await this.startServer();\n      \n      // Setup file watching for hot reload\n      if (this.config.enableHotReload) {\n        await this.setupFileWatcher();\n      }\n\n      // Load existing nodes\n      await this.loadNodes();\n\n      this.isRunning = true;\n      spinner.succeed(chalk.green(`ðŸš€ Development server running at http://${this.config.host}:${this.config.port}`));\n      \n      this.logInfo('Development server features:');\n      if (this.config.enableHotReload) this.logInfo('  âœ“ Hot reload enabled');\n      if (this.config.enableDebugger) this.logInfo('  âœ“ Debugger enabled');\n      if (this.config.enableLivePreview) this.logInfo('  âœ“ Live preview enabled');\n      if (this.config.enableTesting) this.logInfo('  âœ“ Testing enabled');\n      \n      this.emit('started');\n    } catch (error) {\n      spinner.fail(chalk.red('Failed to start development server'));\n      throw error;\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      return;\n    }\n\n    const spinner = ora('Stopping development server...').start();\n\n    try {\n      // Stop file watcher\n      if (this.watcher) {\n        await this.watcher.close();\n      }\n\n      // Stop node process\n      if (this.nodeProcess) {\n        this.nodeProcess.kill();\n      }\n\n      // Close WebSocket connections\n      this.io.close();\n\n      // Close HTTP server\n      if (this.server) {\n        this.server.close();\n      }\n\n      this.isRunning = false;\n      spinner.succeed(chalk.green('Development server stopped'));\n      \n      this.emit('stopped');\n    } catch (error) {\n      spinner.fail(chalk.red('Error stopping development server'));\n      throw error;\n    }\n  }\n\n  private setupExpressApp(): void {\n    this.app = express();\n    \n    // Middleware\n    this.app.use(express.json());\n    this.app.use(express.static(path.join(__dirname, '../public')));\n\n    // API Routes\n    this.setupAPIRoutes();\n    \n    // Serve development UI\n    this.app.get('/', (req, res) => {\n      res.send(this.generateDevelopmentUI());\n    });\n  }\n\n  private setupAPIRoutes(): void {\n    // Node management routes\n    this.app.get('/api/nodes', async (req, res) => {\n      try {\n        const nodes = await this.getAvailableNodes();\n        res.json(nodes);\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    this.app.post('/api/nodes/:nodeId/test', async (req, res) => {\n      try {\n        const { nodeId } = req.params;\n        const testData = req.body;\n        const result = await this.testNode(nodeId, testData);\n        res.json(result);\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    this.app.post('/api/nodes/:nodeId/debug', async (req, res) => {\n      try {\n        const { nodeId } = req.params;\n        const { breakpoints } = req.body;\n        const session = await this.startDebugSession(nodeId, breakpoints);\n        res.json(session);\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    // Debug session management\n    this.app.get('/api/debug/:sessionId', (req, res) => {\n      const session = this.debugSessions.get(req.params.sessionId);\n      if (!session) {\n        return res.status(404).json({ error: 'Debug session not found' });\n      }\n      res.json(session);\n    });\n\n    this.app.post('/api/debug/:sessionId/step', async (req, res) => {\n      try {\n        await this.debugStep(req.params.sessionId);\n        res.json({ success: true });\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    this.app.post('/api/debug/:sessionId/continue', async (req, res) => {\n      try {\n        await this.debugContinue(req.params.sessionId);\n        res.json({ success: true });\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    // Analytics and monitoring\n    this.app.get('/api/analytics', (req, res) => {\n      res.json({\n        ...this.analytics,\n        uptime: Date.now() - this.analytics.uptime,\n        connectedClients: this.connectedClients.size,\n        activeDebugSessions: this.debugSessions.size\n      });\n    });\n\n    // Hot reload endpoint\n    this.app.post('/api/reload', async (req, res) => {\n      try {\n        await this.reloadNodes();\n        res.json({ success: true });\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    // File operations\n    this.app.get('/api/files', async (req, res) => {\n      try {\n        const files = await this.getProjectFiles();\n        res.json(files);\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n\n    this.app.get('/api/files/*', async (req, res) => {\n      try {\n        const filePath = req.params[0];\n        const content = await fs.readFile(filePath, 'utf-8');\n        res.json({ content });\n      } catch (error) {\n        res.status(500).json({ error: error.message });\n      }\n    });\n  }\n\n  private setupSocketIO(): void {\n    this.server = createServer(this.app);\n    this.io = new SocketIOServer(this.server, {\n      cors: {\n        origin: \"*\",\n        methods: [\"GET\", \"POST\"]\n      }\n    });\n\n    this.io.on('connection', (socket) => {\n      const clientId = socket.id;\n      this.connectedClients.add(clientId);\n      \n      this.logInfo(`Client connected: ${clientId}`);\n      \n      socket.on('disconnect', () => {\n        this.connectedClients.delete(clientId);\n        this.logInfo(`Client disconnected: ${clientId}`);\n      });\n\n      // Real-time testing\n      socket.on('test-node', async (data) => {\n        try {\n          const result = await this.testNode(data.nodeId, data.testData);\n          socket.emit('test-result', result);\n        } catch (error) {\n          socket.emit('test-error', { error: error.message });\n        }\n      });\n\n      // Debug session events\n      socket.on('debug-start', async (data) => {\n        try {\n          const session = await this.startDebugSession(data.nodeId, data.breakpoints);\n          socket.emit('debug-session', session);\n        } catch (error) {\n          socket.emit('debug-error', { error: error.message });\n        }\n      });\n\n      // File change notifications\n      socket.on('subscribe-file-changes', () => {\n        socket.join('file-watchers');\n      });\n    });\n  }\n\n  private async startServer(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.server.listen(this.config.port, this.config.host, (error?: Error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  private async setupFileWatcher(): Promise<void> {\n    this.watcher = chokidar.watch(this.config.watchPaths, {\n      ignored: this.config.ignorePaths,\n      persistent: true,\n      ignoreInitial: true\n    });\n\n    this.watcher.on('change', async (filePath) => {\n      this.logInfo(`File changed: ${filePath}`);\n      await this.handleFileChange(filePath);\n    });\n\n    this.watcher.on('add', async (filePath) => {\n      this.logInfo(`File added: ${filePath}`);\n      await this.handleFileChange(filePath);\n    });\n\n    this.watcher.on('unlink', async (filePath) => {\n      this.logInfo(`File removed: ${filePath}`);\n      await this.handleFileChange(filePath);\n    });\n  }\n\n  private async handleFileChange(filePath: string): Promise<void> {\n    try {\n      if (this.config.enableHotReload) {\n        await this.reloadNodes();\n        this.analytics.hotReloads++;\n        \n        // Notify connected clients\n        this.io.to('file-watchers').emit('file-changed', {\n          path: filePath,\n          timestamp: new Date().toISOString()\n        });\n        \n        this.emit('fileChanged', filePath);\n      }\n    } catch (error) {\n      this.logError(`Error handling file change: ${error.message}`);\n    }\n  }\n\n  private async loadNodes(): Promise<void> {\n    // Implementation to load and register nodes\n    this.logInfo('Loading nodes...');\n    // This would scan for node files and register them\n  }\n\n  private async reloadNodes(): Promise<void> {\n    this.logInfo('Reloading nodes...');\n    \n    // Kill existing node process\n    if (this.nodeProcess) {\n      this.nodeProcess.kill();\n    }\n\n    // Reload nodes\n    await this.loadNodes();\n    \n    // Notify clients\n    this.io.emit('nodes-reloaded', {\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  private async testNode(nodeId: string, testData: any): Promise<NodeTestResult> {\n    const startTime = Date.now();\n    const testId = `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    try {\n      this.logInfo(`Testing node: ${nodeId}`);\n      \n      // Simulate node execution (replace with actual execution)\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      const result: NodeTestResult = {\n        nodeId,\n        success: true,\n        output: { message: `Node ${nodeId} executed successfully`, testData },\n        executionTime: Date.now() - startTime,\n        memoryUsage: process.memoryUsage().heapUsed,\n        timestamp: new Date().toISOString(),\n        testData\n      };\n      \n      // Store test result\n      const nodeResults = this.testResults.get(nodeId) || [];\n      nodeResults.push(result);\n      this.testResults.set(nodeId, nodeResults);\n      \n      this.analytics.testsRun++;\n      \n      return result;\n    } catch (error) {\n      const result: NodeTestResult = {\n        nodeId,\n        success: false,\n        error: error.message,\n        executionTime: Date.now() - startTime,\n        memoryUsage: process.memoryUsage().heapUsed,\n        timestamp: new Date().toISOString(),\n        testData\n      };\n      \n      const nodeResults = this.testResults.get(nodeId) || [];\n      nodeResults.push(result);\n      this.testResults.set(nodeId, nodeResults);\n      \n      return result;\n    }\n  }\n\n  private async startDebugSession(nodeId: string, breakpoints: number[]): Promise<DebugSession> {\n    const sessionId = `debug_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const session: DebugSession = {\n      id: sessionId,\n      nodeId,\n      breakpoints,\n      variables: {},\n      callStack: [],\n      isRunning: false,\n      createdAt: new Date().toISOString()\n    };\n    \n    this.debugSessions.set(sessionId, session);\n    this.analytics.debugSessions++;\n    \n    this.logInfo(`Started debug session: ${sessionId} for node: ${nodeId}`);\n    \n    return session;\n  }\n\n  private async debugStep(sessionId: string): Promise<void> {\n    const session = this.debugSessions.get(sessionId);\n    if (!session) {\n      throw new Error('Debug session not found');\n    }\n    \n    // Implement debug step logic\n    this.logInfo(`Debug step: ${sessionId}`);\n  }\n\n  private async debugContinue(sessionId: string): Promise<void> {\n    const session = this.debugSessions.get(sessionId);\n    if (!session) {\n      throw new Error('Debug session not found');\n    }\n    \n    // Implement debug continue logic\n    this.logInfo(`Debug continue: ${sessionId}`);\n  }\n\n  private async getAvailableNodes(): Promise<any[]> {\n    // Scan for available nodes\n    return [];\n  }\n\n  private async getProjectFiles(): Promise<string[]> {\n    // Get list of project files\n    return [];\n  }\n\n  private generateDevelopmentUI(): string {\n    return `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>N8N-Work Development Server</title>\n        <script src=\"/socket.io/socket.io.js\"></script>\n        <style>\n            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }\n            .container { max-width: 1200px; margin: 0 auto; }\n            .header { background: #fff; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n            .section { background: #fff; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n            .status { display: inline-block; padding: 4px 8px; border-radius: 4px; color: white; font-size: 12px; }\n            .status.online { background: #4CAF50; }\n            .status.offline { background: #f44336; }\n            button { background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }\n            button:hover { background: #1976D2; }\n            .log { background: #f9f9f9; padding: 10px; border-radius: 4px; font-family: monospace; height: 200px; overflow-y: auto; }\n        </style>\n    </head>\n    <body>\n        <div class=\"container\">\n            <div class=\"header\">\n                <h1>ðŸš€ N8N-Work Development Server</h1>\n                <span class=\"status online\" id=\"connectionStatus\">Online</span>\n                <p>Real-time development environment for N8N-Work nodes</p>\n            </div>\n            \n            <div class=\"section\">\n                <h2>Quick Actions</h2>\n                <button onclick=\"reloadNodes()\">Reload Nodes</button>\n                <button onclick=\"runTests()\">Run All Tests</button>\n                <button onclick=\"clearLogs()\">Clear Logs</button>\n            </div>\n            \n            <div class=\"section\">\n                <h2>Live Logs</h2>\n                <div class=\"log\" id=\"logs\"></div>\n            </div>\n            \n            <div class=\"section\">\n                <h2>Analytics</h2>\n                <div id=\"analytics\">\n                    <p>Tests Run: <span id=\"testsRun\">0</span></p>\n                    <p>Hot Reloads: <span id=\"hotReloads\">0</span></p>\n                    <p>Connected Clients: <span id=\"connectedClients\">0</span></p>\n                </div>\n            </div>\n        </div>\n        \n        <script>\n            const socket = io();\n            const logs = document.getElementById('logs');\n            const connectionStatus = document.getElementById('connectionStatus');\n            \n            socket.on('connect', () => {\n                connectionStatus.textContent = 'Online';\n                connectionStatus.className = 'status online';\n                addLog('Connected to development server');\n            });\n            \n            socket.on('disconnect', () => {\n                connectionStatus.textContent = 'Offline';\n                connectionStatus.className = 'status offline';\n                addLog('Disconnected from development server');\n            });\n            \n            socket.on('file-changed', (data) => {\n                addLog(\\`File changed: \\${data.path}\\`);\n            });\n            \n            socket.on('nodes-reloaded', () => {\n                addLog('Nodes reloaded successfully');\n            });\n            \n            function addLog(message) {\n                const time = new Date().toLocaleTimeString();\n                logs.innerHTML += \\`<div>[\\${time}] \\${message}</div>\\`;\n                logs.scrollTop = logs.scrollHeight;\n            }\n            \n            function reloadNodes() {\n                fetch('/api/reload', { method: 'POST' })\n                    .then(() => addLog('Reload triggered'))\n                    .catch(err => addLog(\\`Reload error: \\${err.message}\\`));\n            }\n            \n            function runTests() {\n                addLog('Running tests...');\n                // Implement test running\n            }\n            \n            function clearLogs() {\n                logs.innerHTML = '';\n            }\n            \n            // Load analytics\n            function loadAnalytics() {\n                fetch('/api/analytics')\n                    .then(res => res.json())\n                    .then(data => {\n                        document.getElementById('testsRun').textContent = data.testsRun;\n                        document.getElementById('hotReloads').textContent = data.hotReloads;\n                        document.getElementById('connectedClients').textContent = data.connectedClients;\n                    });\n            }\n            \n            // Load analytics every 5 seconds\n            setInterval(loadAnalytics, 5000);\n            loadAnalytics();\n        </script>\n    </body>\n    </html>\n    `;\n  }\n\n  private logInfo(message: string): void {\n    if (this.config.logLevel === 'debug' || this.config.logLevel === 'info') {\n      console.log(chalk.blue('[INFO]'), message);\n    }\n  }\n\n  private logError(message: string): void {\n    console.log(chalk.red('[ERROR]'), message);\n  }\n\n  private logDebug(message: string): void {\n    if (this.config.logLevel === 'debug') {\n      console.log(chalk.gray('[DEBUG]'), message);\n    }\n  }\n}\n\nexport async function startDevServer(options: any): Promise<void> {\n  const config: Partial<DevServerConfig> = {\n    port: parseInt(options.port) || 3000,\n    host: options.host || 'localhost',\n    enableHotReload: !options.noHotReload,\n    enableDebugger: !options.noDebugger,\n    enableTesting: !options.noTesting,\n    logLevel: options.logLevel || 'info'\n  };\n\n  const devServer = new DevServer(config);\n\n  // Handle graceful shutdown\n  process.on('SIGINT', async () => {\n    console.log('\\n' + chalk.yellow('Shutting down development server...'));\n    await devServer.stop();\n    process.exit(0);\n  });\n\n  process.on('SIGTERM', async () => {\n    await devServer.stop();\n    process.exit(0);\n  });\n\n  try {\n    await devServer.start();\n  } catch (error) {\n    console.error(chalk.red('Failed to start development server:'), error.message);\n    process.exit(1);\n  }\n}"
