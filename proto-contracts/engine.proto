syntax = "proto3";

package engine;

option go_package = "./proto/engine";

import "orchestrator.proto";

// Engine service for workflow execution management
service EngineService {
  // Execution Management
  rpc RunWorkflow(RunWorkflowRequest) returns (RunWorkflowResponse);
  rpc StepExec(StepExecRequest) returns (StepExecResponse);
  rpc StepDone(StepDoneRequest) returns (StepDoneResponse);
  rpc CancelExecution(CancelExecutionRequest) returns (CancelExecutionResponse);
  
  // Status and Monitoring
  rpc GetExecutionStatus(GetExecutionStatusRequest) returns (GetExecutionStatusResponse);
  rpc ListActiveExecutions(ListActiveExecutionsRequest) returns (ListActiveExecutionsResponse);
  
  // Resource Management
  rpc GetResourceUsage(GetResourceUsageRequest) returns (GetResourceUsageResponse);
  rpc UpdateRateLimits(UpdateRateLimitsRequest) returns (UpdateRateLimitsResponse);
  
  // Real-time Streaming
  rpc StreamExecutionEvents(StreamExecutionRequest) returns (stream ExecutionEvent);
  rpc StreamStepUpdates(StreamStepRequest) returns (stream StepUpdateEvent);
  rpc StreamResourceMetrics(StreamMetricsRequest) returns (stream ResourceMetricsEvent);
  rpc StreamWorkflowLogs(StreamLogsRequest) returns (stream LogEvent);
  
  // Bidirectional Streaming
  rpc ExecutionChannel(stream ExecutionCommand) returns (stream ExecutionResponse);
  
  // Health Check
  rpc Health(HealthRequest) returns (HealthResponse);
}

message RunWorkflowRequest {
  string execution_id = 1;
  orchestrator.Workflow workflow = 2;
  map<string, string> context = 3;
  string trigger_data = 4;
  string tenant_id = 5;
  ExecutionConfig config = 6;
}

message ExecutionConfig {
  int32 timeout_seconds = 1;
  int32 max_retries = 2;
  bool enable_parallel_execution = 3;
  map<string, string> environment_variables = 4;
  ResourceLimits resource_limits = 5;
}

message ResourceLimits {
  int64 max_memory_bytes = 1;
  int32 max_cpu_millicores = 2;
  int32 max_execution_time_seconds = 3;
  int32 max_network_requests = 4;
}

message RunWorkflowResponse {
  string execution_id = 1;
  bool success = 2;
  string error_message = 3;
  repeated string scheduled_steps = 4;
}

message StepExecRequest {
  string execution_id = 1;
  string step_id = 2;
  string node_id = 3;
  string node_type = 4;
  map<string, string> parameters = 5;
  string input_data = 6;
  orchestrator.NodePolicy policy = 7;
  string tenant_id = 8;
}

message StepExecResponse {
  bool success = 1;
  string error_message = 2;
  string assigned_runner = 3;
}

message StepDoneRequest {
  string execution_id = 1;
  string step_id = 2;
  orchestrator.StepStatus status = 3;
  string output_data = 4;
  string error_message = 5;
  int32 retry_count = 6;
  ExecutionMetrics metrics = 7;
}

message ExecutionMetrics {
  int64 execution_time_ms = 1;
  int64 memory_used_bytes = 2;
  int32 network_requests_count = 3;
  int64 network_bytes_sent = 4;
  int64 network_bytes_received = 5;
}

message StepDoneResponse {
  bool success = 1;
  string error_message = 2;
  repeated string next_steps = 3;
}

message CancelExecutionRequest {
  string execution_id = 1;
  string reason = 2;
  string tenant_id = 3;
}

message CancelExecutionResponse {
  bool success = 1;
  string error_message = 2;
  repeated string cancelled_steps = 3;
}

message GetExecutionStatusRequest {
  string execution_id = 1;
  string tenant_id = 2;
}

message GetExecutionStatusResponse {
  orchestrator.ExecutionStatus status = 1;
  repeated orchestrator.StepExecution steps = 2;
  ExecutionProgress progress = 3;
  bool success = 4;
  string error_message = 5;
}

message ExecutionProgress {
  int32 total_steps = 1;
  int32 completed_steps = 2;
  int32 failed_steps = 3;
  int32 running_steps = 4;
  int32 pending_steps = 5;
  double completion_percentage = 6;
}

message ListActiveExecutionsRequest {
  string tenant_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListActiveExecutionsResponse {
  repeated ActiveExecution executions = 1;
  string next_page_token = 2;
  bool success = 3;
  string error_message = 4;
}

message ActiveExecution {
  string execution_id = 1;
  string workflow_id = 2;
  orchestrator.ExecutionStatus status = 3;
  string started_at = 4;
  ExecutionProgress progress = 5;
  ResourceUsage resource_usage = 6;
}

message GetResourceUsageRequest {
  string tenant_id = 1;
  string execution_id = 2; // optional, if empty returns tenant-wide usage
}

message GetResourceUsageResponse {
  ResourceUsage usage = 1;
  bool success = 2;
  string error_message = 3;
}

message ResourceUsage {
  int64 memory_used_bytes = 1;
  int32 cpu_used_millicores = 2;
  int32 active_executions = 3;
  int32 queued_executions = 4;
  int64 network_bytes_per_minute = 5;
  int32 requests_per_minute = 6;
}

message UpdateRateLimitsRequest {
  string tenant_id = 1;
  RateLimits limits = 2;
}

message RateLimits {
  int32 max_executions_per_minute = 1;
  int32 max_concurrent_executions = 2;
  int32 max_requests_per_minute = 3;
  int64 max_bandwidth_bytes_per_minute = 4;
}

message UpdateRateLimitsResponse {
  bool success = 1;
  string error_message = 2;
}

message HealthRequest {}

message HealthResponse {
  string status = 1;
  map<string, string> details = 2;
}

// Streaming Messages

// Execution Event Streaming
message StreamExecutionRequest {
  string execution_id = 1;
  string tenant_id = 2;
  repeated ExecutionEventType event_types = 3;
}

enum ExecutionEventType {
  EXECUTION_EVENT_UNKNOWN = 0;
  EXECUTION_STARTED = 1;
  EXECUTION_COMPLETED = 2;
  EXECUTION_FAILED = 3;
  EXECUTION_CANCELLED = 4;
  STEP_STARTED = 5;
  STEP_COMPLETED = 6;
  STEP_FAILED = 7;
  STEP_RETRYING = 8;
  RESOURCE_LIMIT_EXCEEDED = 9;
  EXECUTION_PAUSED = 10;
  EXECUTION_RESUMED = 11;
}

message ExecutionEvent {
  string execution_id = 1;
  ExecutionEventType event_type = 2;
  string timestamp = 3;
  string step_id = 4; // optional, for step-specific events
  map<string, string> data = 5;
  ExecutionProgress progress = 6;
  string message = 7;
  orchestrator.ExecutionStatus status = 8;
}

// Step Update Streaming
message StreamStepRequest {
  string execution_id = 1;
  string step_id = 2; // optional, if empty streams all steps
  string tenant_id = 3;
}

message StepUpdateEvent {
  string execution_id = 1;
  string step_id = 2;
  string node_id = 3;
  orchestrator.StepStatus status = 4;
  string timestamp = 5;
  string input_data = 6;
  string output_data = 7;
  string error_message = 8;
  ExecutionMetrics metrics = 9;
  int32 retry_count = 10;
  map<string, string> metadata = 11;
}

// Resource Metrics Streaming
message StreamMetricsRequest {
  string tenant_id = 1;
  string execution_id = 2; // optional
  int32 interval_seconds = 3; // metrics reporting interval
  repeated MetricType metric_types = 4;
}

enum MetricType {
  METRIC_UNKNOWN = 0;
  CPU_USAGE = 1;
  MEMORY_USAGE = 2;
  NETWORK_IO = 3;
  DISK_IO = 4;
  EXECUTION_RATE = 5;
  ERROR_RATE = 6;
  QUEUE_LENGTH = 7;
  RESPONSE_TIME = 8;
}

message ResourceMetricsEvent {
  string timestamp = 1;
  string tenant_id = 2;
  string execution_id = 3; // optional
  MetricType metric_type = 4;
  double value = 5;
  string unit = 6;
  map<string, string> labels = 7;
  ResourceUsage resource_usage = 8;
}

// Log Streaming
message StreamLogsRequest {
  string execution_id = 1;
  string step_id = 2; // optional
  string tenant_id = 3;
  LogLevel min_level = 4;
  bool follow = 5; // if true, keeps streaming new logs
  int32 tail_lines = 6; // number of recent lines to include
}

enum LogLevel {
  LOG_UNKNOWN = 0;
  DEBUG = 1;
  INFO = 2;
  WARN = 3;
  ERROR = 4;
  FATAL = 5;
}

message LogEvent {
  string timestamp = 1;
  string execution_id = 2;
  string step_id = 3;
  string node_id = 4;
  LogLevel level = 5;
  string message = 6;
  map<string, string> fields = 7;
  string source = 8; // component that generated the log
  string trace_id = 9; // for distributed tracing
}

// Bidirectional Streaming
message ExecutionCommand {
  string command_id = 1;
  string execution_id = 2;
  string tenant_id = 3;
  ExecutionCommandType command_type = 4;
  map<string, string> parameters = 5;
  string timestamp = 6;
}

enum ExecutionCommandType {
  COMMAND_UNKNOWN = 0;
  PAUSE_EXECUTION = 1;
  RESUME_EXECUTION = 2;
  CANCEL_EXECUTION = 3;
  SKIP_STEP = 4;
  RETRY_STEP = 5;
  UPDATE_VARIABLES = 6;
  SET_BREAKPOINT = 7;
  REMOVE_BREAKPOINT = 8;
  GET_SNAPSHOT = 9;
}

message ExecutionResponse {
  string command_id = 1;
  string execution_id = 2;
  bool success = 3;
  string error_message = 4;
  string timestamp = 5;
  ExecutionResponseType response_type = 6;
  map<string, string> data = 7;
}

enum ExecutionResponseType {
  RESPONSE_UNKNOWN = 0;
  COMMAND_ACKNOWLEDGED = 1;
  COMMAND_COMPLETED = 2;
  COMMAND_FAILED = 3;
  EXECUTION_SNAPSHOT = 4;
  EXECUTION_STATE_CHANGED = 5;
  HEARTBEAT = 6;
}
